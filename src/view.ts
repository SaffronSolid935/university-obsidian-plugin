import { VIEW_IMPORTER, ImporterPopUpView } from 'src/files/import/importer';
import { VIEW_LECUTRE_IMPORTER } from 'src/files/import/lectureInporter';
import { VIEW_READING_IMPORTER } from 'src/files/import/readingImporter';
import { MetaHandler } from 'src/files/metaHandler';
import UnivresityPlugin from 'main';
import { FileManager, ItemView, Notice, Plugin, TAbstractFile, TFile, WorkspaceLeaf } from 'obsidian';

//#region constants

//#region subpaths
export const NOTES = 'notes';
export const LECTURES = 'lectures';
export const READINGS = 'readings';
//#endregion

/**
 * The view id of the University-View
 */
export const VIEW_UNIVERSITY = 'University';
//#endregion

/**
 * Template for the navbar. It contains all neccessary properties to behave right.
 */
interface INavbarData 
{
    /**
     * Important: the programm will not check if two navbar items have the same id.
     */
    id: string;
    label: string;
    /**
     * This is called, when a tab in the navbar has been clicked (and selected).
     * @param documentSection 
     * @returns 
     */
    onClick: (documentSection: DocumentSection) => any;
    element: HTMLLIElement | null;
    documentSection: DocumentSection
}

/**
 * Used to different the section, in wich the user is.
 */

enum DocumentSection
{  
    Notes,
    Lectures,
    Readings
}

/**
 * obsolete
 */

interface IFileData
{
    name: string;
    filename: string;
    path: string;
    date: Date | undefined;
    abstractFile: TAbstractFile;
}

/**
 * The main view of the university plugin.
 * Normaly instantiated by the university plugin it self.
 */
export class UniversityView extends ItemView
{

    //#region properties
    /**
     * Stores the section, in wich the user could be. 
     * Default and star section: Notes
     */
    private currentDocumentSection: DocumentSection = DocumentSection.Notes;


    /**
     * Stores the behavior vor the several sections.
     */
    private navbarData: Array<INavbarData> = [
        {
            id: NOTES,
            label: 'Notes',
            onClick: (id) => {this.onNavbarClick(id)},
            element: null,
            documentSection: DocumentSection.Notes
        },
        {
            id: 'lectures',
            label: 'Lectures',
            onClick: (id) => {this.onNavbarClick(id)},
            element: null,
            documentSection: DocumentSection.Lectures
        },
        {
            id: 'readings',
            label: 'Readings',
            onClick: (id) => {this.onNavbarClick(id)},
            element: null,
            documentSection: DocumentSection.Readings
        }
    ];

    /**
     * Stores the university plugin, so this view can access the settings.
     */
    private plugin: UnivresityPlugin;
    /**
     * This array stores the readable options for the semester section. (Generated by generateSemesterOptions).
     */
    private semesterOptions: Array<string> = [];

    /**
     * Stores a leaf, when a sub view will be opened. 
     * This is needed, to automatically close the subview, when this view is closed.
     */
    private subLeaf: WorkspaceLeaf;

    /**
     * Stores the save settings method, due of changing some settings.
     */
    private saveSettings: ()=>Promise<any>;

    //#endregion
    
    /**
     * Initializes the university main view.
     * @param leaf 
     * @param plugin 
     * @param saveSettingsMethod The method to save the changed settings. Normally automatically setted.
     */
    constructor (leaf: WorkspaceLeaf, plugin: UnivresityPlugin, saveSettingsMethod: ()=>Promise<any>)
    {
        super(leaf);
        this.plugin = plugin;
        this.saveSettings = saveSettingsMethod;
        plugin.setUniversityView(this);
    }

    //#region Lifecyclye
    getViewType()
    {
        return VIEW_UNIVERSITY;
    }

    getDisplayText(): string {
        return 'University (view)';
    }

    getIcon(): string {
        return 'graduation-cap';
    }

    async onOpen()
    {
        await this.generateCurrentFolderIfNotExists();
        const container = this.containerEl.children[1];
        container.empty();
        if (!container.classList.contains('university-view-container'))
            container.addClass('university-view-container');

        if (this.semesterOptions.length != this.plugin.settings.semesters)
        {
            this.generateSemesterOptions();
        }
        
        var semesterCombobox = await this.generateSelection(
            container,
            'semester-select',
            this.semesterOptions,
            this.plugin.settings.currentSemester,
            async (event, index, value)=>{
                const select = event.target as HTMLSelectElement;
                await this.selectSemester(index);
                await this.onOpen();
            }
        );

        let moduleList = this.plugin.settings.modules[this.plugin.settings.currentSemester]
        
        var moduleCombobox = await this.generateSelection(
            container,
            'module-select',
            moduleList,
            this.plugin.settings.lastSelectedModuleIndex,
            async (event, index, value) => {
                await this.selectModule(index);
            }
        );

        await this.generateNavBar(container);

        let sectionPath;
        switch (this.currentDocumentSection)
        {
            case DocumentSection.Notes:
                sectionPath = await this.createSubFolderIfNotExists(NOTES);
                this.plugin.noteFileCreator.setPath(sectionPath);
                await this.generateFileSection(container,this.plugin.noteFileCreator, 'Create note',async ()=>{
                    const path = await this.plugin.noteFileCreator.createFileAsync();

                    if (path)
                    {
                        const opened = await this.plugin.noteFileCreator.openFileInEditor(path);
                        if (!opened)
                        {
                            console.log('Error while opening note (301)');
                            new Error('Error while opening note (301)');
                        }
                    }
                    else
                    {
                        console.log('Could not create note (300)');
                        new Error('Could not create note (300)');
                    }
                    this.onOpen();
                });
                break;
            case DocumentSection.Lectures:
                sectionPath = await this.createSubFolderIfNotExists(LECTURES);
                this.plugin.lectureFileCreator.setPath(sectionPath);
                await this.generateFileSection(container, this.plugin.lectureFileCreator, 'Import lecture', async ()=>{
                    // const path = await this._plugin.lectureFileCreator.importFile()

                    // new UniversityView();
                    const { workspace } = this.app;

                    let leaf: WorkspaceLeaf | null = null;
                    const leaves = workspace.getLeavesOfType(VIEW_LECUTRE_IMPORTER);

                    if (leaves.length > 0)
                    {
                        leaf = leaves[0];
                    } else 
                    {
                        leaf = workspace.getRightLeaf(false);
                        await leaf?.setViewState({ type: VIEW_LECUTRE_IMPORTER, active: true});
                    }

                    if (leaf != null)
                    {
                        this.subLeaf = leaf;
                        workspace.revealLeaf(leaf);
                    }
                    else
                    {
                        console.log('Error on opening importer (302a)');
                        new Notice('Error on opening importer (302a)');
                    }
                });
                break;
            case DocumentSection.Readings:
                // await this.generateReadingsSection(container);
                sectionPath = await this.createSubFolderIfNotExists(READINGS);
                this.plugin.readingFileCreator.setPath(sectionPath);
                await this.generateFileSection(container,this.plugin.readingFileCreator,'Import reading',async ()=>{
                    const { workspace } = this.app;

                    let leaf: WorkspaceLeaf | null = null;
                    const leaves = workspace.getLeavesOfType(VIEW_READING_IMPORTER);

                    if (leaves.length > 0)
                    {
                        leaf = leaves[0];
                    } else 
                    {
                        leaf = workspace.getRightLeaf(false);
                        await leaf?.setViewState({ type: VIEW_READING_IMPORTER, active: true});
                    }

                    if (leaf != null)
                    {
                        this.subLeaf = leaf;
                        workspace.revealLeaf(leaf);
                    }
                    else
                    {
                        console.log('Error on opening importer (302b)');
                        new Notice('Error on opening importer (302b)');
                    }
                });
                break;
        }
    }

    /**
     * Generates the file selection in the university view. Handles the sorting of the files and also handling the create/import button.
     * @param container The container, in wich the file section should be created.
     * @param fileCreator The filecreator, wich creates the files, wich should be created or imported. Also needed to list the files.
     * @param fileCreateText The text for the create/import button at the bottom of this view.
     * @param fileCreateMethod Defines, what to do, when the button is pressed.
     */
    private async generateFileSection(container: Element, fileCreator: MetaHandler, fileCreateText: string, fileCreateMethod: (event: MouseEvent)=>any)
    {

        const files = await fileCreator.getFilesAsync();

        const div = container.createDiv();
        div.addClass('university-notes-div');

        files.forEach((value)=>{
            let button = div.createEl('button',{text:value.label});
            button.addEventListener('click',async ()=>{
                var opened = await fileCreator.openFileInEditor(value.path);
                if (!opened)
                {
                    console.error(`File ${value.path} not found (303a).`);
                    new Notice(`File '${value.name}' not found (303a).`);
                }
            });

            button.addEventListener('mouseup',async (event)=>{
                if (event.button === 1)
                {
                    var opened = await fileCreator.openFileInEditor(value.path, false);
                    if (!opened)
                    {
                        console.error(`File ${value.path} not found (code: 303b).`);
                        new Notice(`File '${value.name}' not found (303b).`);
                    }
                }
            });
        });

        const button = container.createEl('button',{text:fileCreateText});
        button.addClass('university-notes-create-button');
        button.addEventListener('click',fileCreateMethod);
    }

    /**
     * Generates the navbar.
     * It uses the property navbarData to create the navbar.
     * Default elements: Notes, Lectures, Readings
     * @param container 
     */
    private async generateNavBar(container: Element)
    {
        let navbar = container.createEl('ul');
        navbar.addClass('university-navbar-parent')

        this.navbarData.forEach((navbarItem, index)=>{ // here
            let navbarOption = navbar.createEl('li');
            navbarOption.createEl('label',{text:navbarItem.label});
            navbarOption.addClass('university-navbar-child');
            navbarOption.addEventListener('click',(event)=>{navbarItem.onClick(navbarItem.documentSection)});
            this.navbarData[index].element = navbarOption;
        });

        this.navbarData.forEach((value) => {
            if (value.documentSection == this.currentDocumentSection)
            {
            }
            if (value.element != null)
            value.element.className = value.documentSection == this.currentDocumentSection ? 'university-navbar-child-active' : 'university-navbar-child';
        });


    }

    /**
     * Generates a selection (aka. dropbox or combobox) by the given data.
     * @param container 
     * @param id The id wich should the selection have.
     * @param options The options which can be selected.
     * @param selectedIndex This defines the selected item.
     * @param listener Defines what to do, when selected item was changed. 
     * @returns 
     */
    private async generateSelection(container: Element, id: string, options: Array<string>, selectedIndex: number, listener: (ev: Event, index: number, value: string) => any) : Promise<HTMLSelectElement>
    {
        let combobox = container.createEl('select');
        combobox.id = id;
        options.forEach((value, index) =>
        {
            let option = combobox.createEl('option');
            option.innerText = value;
            option.value = index.toString();
        }); 
        
        combobox.selectedIndex = selectedIndex;
        combobox.addEventListener('change', (event)=>{
            listener(event, combobox.selectedIndex, options[combobox.selectedIndex]);
        });

        combobox.addClass("university-combobox")

        return combobox;
    }


    async onClose() {
        this.subLeaf.detach();
    }

    //#endregion

    //#region Helping method
    /**
     * Generates for the user readable semester options.
     */
    
    private generateSemesterOptions()
    {
        for (var i = 0; i < this.plugin.settings.semesters; i++)
        {
            this.semesterOptions.push(`Semester ${i + 1}`);
        }
    }

    /**
     * Creates a subfolder under the selected semester and module.
     * @param sub 
     * @returns 
     */
    private async createSubFolderIfNotExists(sub: string) : Promise<string>
    {
        const path = this.plugin.getSubModulePath(sub);
        const adapter = this.app.vault.adapter;
        if (!(await adapter.exists(path)))
        {
            this.app.vault.createFolder(path);
        }
        return path;
    }
    
    /**
     * handles a click on the navbar (notes, lectures, readings)
     * @param documentSection 
     */
    private onNavbarClick(documentSection: DocumentSection)
    {
        this.currentDocumentSection = documentSection;
        this.onOpen();
    }
    
    /**
     * Returns the navbarData by id.
     * @param id 
     * @returns 
     */
    private getNavbarItem(id: string):INavbarData | null
    {
        for (var i = 0; i < this.navbarData.length; i++)
        {
            if (this.navbarData[i].id == id)
            {
                return this.navbarData[i];
            }
        }
        return null;
    }


    /**
     * Generates the modulepath if it does not exists.
     * Normaly called by a lifecycle method.
     */
    private async generateCurrentFolderIfNotExists()
    {   
        const path = this.plugin.getModulePath();
        const adapter = this.app.vault.adapter;
        if (!(await adapter.exists(path)))
        {
            this.app.vault.createFolder(path);
        }
    }

    /**
     * This methods selects and saves the semester. This is used to remember, where the user is and was, after reopening it.
     * @param index 
     */
    private async selectSemester(index: number)
    {
        this.plugin.settings.currentSemester = index;
        this.plugin.settings.lastSelectedModuleIndex = 0;
        this.saveSettings();
        new Notice(`Semester ${index + 1} selected`);

        const path = this.plugin.getSemesterPath();

        const adapter = this.app.vault.adapter;

        if (!(await adapter.exists(path)))
        {
            await this.app.vault.createFolder(path);
        }
    }
    
    /**
     * This methods selects and saves the module. This is used to remember, where the user is and was, after reopening it.
     * @param index 
     */
    private async selectModule(index: number)
    {
        this.plugin.settings.lastSelectedModuleIndex = index;
        this.saveSettings();
        
        const path = this.plugin.getModulePath();;
        
        const adapter = this.app.vault.adapter;
        
        if (!(await adapter.exists(path)))
        {
            await this.app.vault.createFolder(path);
        }
        this.onOpen();
        
    }
    //#endregion
}